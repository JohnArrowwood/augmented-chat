describe( 'Analysis', function() {

    function ValidateAnalysis( obj ) {
        return new ObjectValidator( obj );
    }

    let init;

    beforeEach( () => {
        init = {
            id: crypto.randomUUID(),
            article_id: crypto.randomUUID(),
            status: Status.CONFIRMED,
            notes: "nothing meaningful",
            created_date: Date.now() - 100,
            analysis_started_date: Date.now() - 75,
            analysis_completed_date: Date.now() - 25,
        };
    });

    describe( 'Constructor', function() {

        test( 'creates a mutable object' )
        .given( 'a properly initialized Analysis' )
        .when(  'inspected' )
        .then(  'the object will NOT be frozen/immutable', 
            function() {
                const analysis = new Analysis( init );
                expect( Object.isFrozen( analysis ) ).to.be.false;
            }
        )

        test( 'default constructor' )
        .given( 'no parameters to the constructor' )
        .when(  'a Analysis is constructed' )
        .then(  'an error is thrown', 
            function () {
                expect( () => new Analysis() ).to.throw();
            }
        );

        describe( 'id', function() {

            test( 'id omitted' )
            .given( 'everything but the id' )
            .when(  'the record is created' )
            .then(  'an id is generated by default',
                function() {
                    delete init.id;
                    const analysis = new Analysis( init );
                    ValidateAnalysis( analysis )
                        .id_is_uuid
                        .validate();
                }
            );
    
            test( 'id provided' )
            .given( 'everything including the id' )
            .when(  'the record is created' )
            .then(  'the id is used',
                function() {
                    const analysis = new Analysis( init );
                    ValidateAnalysis( analysis )
                        .id_is( init.id )
                        .validate();
                }
            );
    
            test( 'id malformed' )
            .given( 'an id that is not a UUID' )
            .when(  'the record is created' )
            .then(  'an error is thrown',
                function() {
                    init.id = 'not-a-uuid';
                    expect( () => new Analysis( init ) ).to.throw();
                }
            );
    
        });

        describe( 'article_id', function() {

            test( 'article_id omitted' )
            .given( 'everything but the article_id' )
            .when(  'the record is created' )
            .then(  'an error is thrown',
                function() {
                    delete init.article_id;
                    expect( () => new Analysis( init ) ).to.throw();
                }
            );
    
            test( 'article_id provided' )
            .given( 'everything including the article_id' )
            .when(  'the record is created' )
            .then(  'the article_id is used',
                function() {
                    const analysis = new Analysis( init );
                    ValidateAnalysis( analysis )
                        .article_id_is( init.article_id )
                        .validate();
                }
            );
    
            test( 'article_id malformed' )
            .given( 'an article_id that is not a UUID' )
            .when(  'the record is created' )
            .then(  'an error is thrown',
                function() {
                    init.article_id = 'not-a-uuid';
                    expect( () => new Analysis( init ) ).to.throw();
                }
            );
    
        });

        describe( 'status', function() {

            test( 'status not provided' )
            .given( 'no status' )
            .when(  'the analysis record is created' )
            .then(  'the status starts as NEW',
                function() {
                    delete init.status;
                    const analysis = new Analysis( init );
                    ValidateAnalysis( analysis )
                        .status_is( Status.NEW )
                        .validate();
    
                }
            );
    
            test( 'provided status is NEW' )
            .given( 'status of NEW' )
            .when(  'record created' )
            .then(  'provided status is used',
                function() {
                    init.status = Status.NEW;
                    const analysis = new Analysis( init );
                    ValidateAnalysis( analysis )
                        .status_is( init.status )
                        .validate();
                }
            );
    
            test( 'provided status is IN_PROGRESS' )
            .given( 'status of IN_PROGRESS' )
            .when(  'record created' )
            .then(  'provided status is used',
                function() {
                    init.status = Status.IN_PROGRESS;
                    const analysis = new Analysis( init );
                    ValidateAnalysis( analysis )
                        .status_is( init.status )
                        .validate();
                }
            );
    
            test( 'provided status is FAILED' )
            .given( 'status of FAILED' )
            .when(  'record created' )
            .then(  'provided status is used',
                function() {
                    init.status = Status.FAILED;
                    const analysis = new Analysis( init );
                    ValidateAnalysis( analysis )
                        .status_is( init.status )
                        .validate();
                }
            );
    
            test( 'provided status is CONFIRMED' )
            .given( 'status of CONFIRMED' )
            .when(  'record created' )
            .then(  'provided status is used',
                function() {
                    init.status = Status.CONFIRMED;
                    const analysis = new Analysis( init );
                    ValidateAnalysis( analysis )
                        .status_is( init.status )
                        .validate();
                }
            );
    
            test( 'provided status is REFUTED' )
            .given( 'status of REFUTED' )
            .when(  'record created' )
            .then(  'provided status is used',
                function() {
                    init.status = Status.REFUTED;
                    const analysis = new Analysis( init );
                    ValidateAnalysis( analysis )
                        .status_is( init.status )
                        .validate();
                }
            );
    
            test( 'provided status is UNCLEAR' )
            .given( 'status of UNCLEAR' )
            .when(  'record created' )
            .then(  'provided status is used',
                function() {
                    init.status = Status.UNCLEAR;
                    const analysis = new Analysis( init );
                    ValidateAnalysis( analysis )
                        .status_is( init.status )
                        .validate();
                }
            );

            test( 'provided status is invalid' )
            .given( 'status is a string' )
            .when(  'record created' )
            .then(  'an error is thrown',
                function() {
                    init.status = 'not-a-status';
                    expect( () => new Analysis( init ) ).to.throw();
                }
            );

            test( 'provided status is unrecognized' )
            .given( 'status is not one of the known symbols' )
            .when(  'record created' )
            .then(  'an error is thrown',
                function() {
                    init.status = Symbol('unrecognized-status');
                    expect( () => new Analysis( init ) ).to.throw();
                }
            );

        });

        describe( 'notes', function() {

            test( 'notes not provided' )
            .given( 'an initialization that omits notes' )
            .when(  'record create' )
            .then(  'notes is an empty string',
                function() {
                    delete init.notes;
                    const analysis = new Analysis( init );
                    ValidateAnalysis( analysis )
                        .notes_is_empty
                        .validate();
                }
            );

            test( 'notes is provided' )
            .given( 'an initialization that includes notes' )
            .when(  'record create' )
            .then(  'notes is as provided',
                function() {
                    init.notes = "some-meaningless-value";
                    const analysis = new Analysis( init );
                    ValidateAnalysis( analysis )
                        .notes_is( init.notes )
                        .validate();
                }
            );

            test( 'notes is not a string' )
            .given( 'a note that is not a string' )
            .when(  'record create' )
            .then(  'an error is thrown',
                function() {
                    init.notes = Symbol('nothing');
                    expect( () => new Analysis( init ) ).to.throw();
                }
            );

        });

        describe( 'created_date', function() {

            test( 'created_date not provided' )
            .given( 'created_date is omitted' )
            .when(  'record created' )
            .then(  'created_date defaults to now',
                function() {
                    delete init.created_date;
                    const analysis = new Analysis( init );
                    ValidateAnalysis( analysis )
                        .created_date_is_within( 10 )
                        .validate();

                }
            ); 

            test( 'created_date is provided' )
            .given( 'created_date is provided' )
            .when(  'record created' )
            .then(  'provided value is used',
                function() {
                    init.created_date = Date.now() - 123456;
                    const analysis = new Analysis( init );
                    ValidateAnalysis( analysis )
                        .created_date_is( init.created_date )
                        .validate();
                }
            );

            test( 'created_date is malformed' )
            .given( 'created_date is not a number' )
            .when(  'record created' )
            .then(  'an error is thrown',
                function() {
                    init.created_date = '2024-01-02 12:34:56';
                    expect( () => new Analysis( init ) ).to.throw();
                }
            );

        });

        describe( 'analysis_started_date', function() {

            test( 'analysis_started_date not provided' )
            .given( 'analysis_started_date is omitted' )
            .when(  'record created' )
            .then(  'analysis_started_date defaults to null',
                function() {
                    delete init.analysis_started_date;
                    const analysis = new Analysis( init );
                    ValidateAnalysis( analysis )
                        .analysis_started_date_is_null
                        .validate();

                }
            ); 

            test( 'analysis_started_date is provided' )
            .given( 'analysis_started_date is provided' )
            .when(  'record created' )
            .then(  'provided value is used',
                function() {
                    init.analysis_started_date = Date.now() - 123456;
                    const analysis = new Analysis( init );
                    ValidateAnalysis( analysis )
                        .analysis_started_date_is( init.analysis_started_date )
                        .validate();
                }
            );

            test( 'analysis_started_date is malformed' )
            .given( 'analysis_started_date is not a number' )
            .when(  'record created' )
            .then(  'an error is thrown',
                function() {
                    init.analysis_started_date = '2024-01-02 12:34:56';
                    expect( () => new Analysis( init ) ).to.throw();
                }
            );

        });

        describe( 'analysis_completed_date', function() {

            test( 'analysis_completed_date not provided' )
            .given( 'analysis_completed_date is omitted' )
            .when(  'record created' )
            .then(  'analysis_completed_date defaults to null',
                function() {
                    delete init.analysis_completed_date;
                    const analysis = new Analysis( init );
                    ValidateAnalysis( analysis )
                        .analysis_completed_date_is_null
                        .validate();

                }
            ); 

            test( 'analysis_completed_date is provided' )
            .given( 'analysis_completed_date is provided' )
            .when(  'record created' )
            .then(  'provided value is used',
                function() {
                    init.analysis_completed_date = Date.now() - 123456;
                    const analysis = new Analysis( init );
                    ValidateAnalysis( analysis )
                        .analysis_completed_date_is( init.analysis_completed_date )
                        .validate();
                }
            );

            test( 'analysis_completed_date is malformed' )
            .given( 'analysis_completed_date is not a number' )
            .when(  'record created' )
            .then(  'an error is thrown',
                function() {
                    init.analysis_completed_date = '2024-01-02 12:34:56';
                    expect( () => new Analysis( init ) ).to.throw();
                }
            );

        });

    });

    describe( 'Getters', function() {

        // NOTE: Everything in this section is redundant
        // as the AnalysisValidator exercises the getters
        // but this will help isolate any getter related problems

        test( 'get id' )
        .given( 'an initialized Analysis' )
        .when(  'the id getter is called' )
        .then(  'it returns the expected value', 
            function () {
                const analysis = new Analysis( init );
                expect( analysis.id ).to.equal( init.id );
            }
        );

        test( 'get article_id' )
        .given( 'an initialized Analysis' )
        .when(  'the article_id getter is called' )
        .then(  'it returns the expected value', 
            function () {
                const analysis = new Analysis( init );
                expect( analysis.article_id ).to.equal( init.article_id );
            }
        );

        test( 'get status' )
        .given( 'an initialized Analysis' )
        .when(  'the status getter is called' )
        .then(  'it returns the expected value', 
            function () {
                const analysis = new Analysis( init );
                expect( analysis.status ).to.equal( init.status );
            }
        );

        test( 'get notes' )
        .given( 'an initialized Analysis' )
        .when(  'the notes getter is called' )
        .then(  'it returns the expected value', 
            function () {
                const analysis = new Analysis( init );
                expect( analysis.notes ).to.equal( init.notes );
            }
        );

        test( 'get created_date' )
        .given( 'an initialized Analysis' )
        .when(  'the created_date getter is called' )
        .then(  'it returns the expected value', 
            function () {
                const analysis = new Analysis( init );
                expect( analysis.created_date ).to.equal( init.created_date );
            }
        );

        test( 'get analysis_started_date' )
        .given( 'an initialized Analysis' )
        .when(  'the analysis_started getter is called' )
        .then(  'it returns the expected value', 
            function () {
                const analysis = new Analysis( init );
                expect( analysis.analysis_started_date ).to.equal( init.analysis_started_date );
            }
        );

        test( 'get analysis_completed_date' )
        .given( 'an initialized Analysis' )
        .when(  'the analysis_completed_date getter is called' )
        .then(  'it returns the expected value', 
            function () {
                const analysis = new Analysis( init );
                expect( analysis.analysis_completed_date ).to.equal( init.analysis_completed_date );
            }
        );


    });

    describe( 'begin()', function() {

        test( 'status must be NEW' )
        .given( 'a status other than NEW' )
        .when(  'begin() is called' )
        .then(  'an error is thrown', 
            function() {
                const list = Object.values( Status ).filter( x => x != Status.NEW );
                list.forEach( (status) => {
                    init.status = status;
                    const analysis = new Analysis( init );
                    expect( () => analysis.begin() ).to.throw();
                });
            }
        );

        test( 'changes status to IN_PROGRESS' )
        .given( 'a NEW analysis' )
        .when(  'begin() is called' )
        .then(  'the record is moved to IN_PROGRESS', 
            function() {
                init.status = Status.NEW;
                const analysis = new Analysis( init );
                analysis.begin();
                ValidateAnalysis( analysis )
                    .analysis_started_date_is_within( 10 )
                    .status_is( Status.IN_PROGRESS )
                    .validate();
            }
        );
    
    });

    describe( 'end()', function() {

        test( 'status must be IN_PROGRESS' )
        .given( 'a status other than IN_PROGRESS' )
        .when(  'end() is called' )
        .then(  'an error is thrown', 
            function() {
                const list = Object.values( Status ).filter( x => x != Status.IN_PROGRESS );
                list.forEach( (status) => {
                    init.status = status;
                    const analysis = new Analysis( init );
                    expect( () => analysis.end( Status.CONFIRMED, "No Notes" ) ).to.throw();
                });
            }
        );

        test( 'changes' )
        .given( 'a IN_PROGRESS analysis' )
        .when(  'end() is called' )
        .then(  'the record is updated as required', 
            function() {
                init.status = Status.NEW;
                const analysis = new Analysis( init );
                analysis.begin();
                analysis.end( Status.CONFIRMED, "No notes" );
                ValidateAnalysis( analysis )
                    .analysis_completed_date_is_within( 10 )
                    .status_is( Status.CONFIRMED )
                    .notes_is( "No notes" )
                    .validate();
            }
        );

        test( 'target status unrecognized' )
        .given( 'an analysis in progress' )
        .when(  'ending the analysis with an unknown status' )
        .then(  'an error is thrown', 
            function() {
                init.status = Status.NEW;
                const analysis = new Analysis( init );
                analysis.begin();
                expect( () => analysis.end( Symbol('invalid'), "meaningless" ) ).to.throw();
            }
        );

        test( 'notes empty' )
        .given( 'an analysis in progress' )
        .when(  'ending the analysis with an empty notes' )
        .then(  'an error is thrown', 
            function() {
                init.status = Status.NEW;
                const analysis = new Analysis( init );
                analysis.begin();
                expect( () => analysis.end( Status.REFUTED, "" ) ).to.throw();
            }
        );

    });

});